
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auth-service/docs/docs.go (0.0%)</option>
				
				<option value="file1">auth-service/domain/entities/token.go (100.0%)</option>
				
				<option value="file2">auth-service/domain/entities/user.go (100.0%)</option>
				
				<option value="file3">auth-service/domain/services/password_service.go (100.0%)</option>
				
				<option value="file4">auth-service/domain/services/seed_service.go (69.2%)</option>
				
				<option value="file5">auth-service/domain/validators/validators.go (85.2%)</option>
				
				<option value="file6">auth-service/entrypoints/api/auth_controller.go (0.0%)</option>
				
				<option value="file7">auth-service/entrypoints/api/health_controller.go (0.0%)</option>
				
				<option value="file8">auth-service/entrypoints/api/routes.go (0.0%)</option>
				
				<option value="file9">auth-service/entrypoints/api/token_controller.go (0.0%)</option>
				
				<option value="file10">auth-service/infrastructure/di/container.go (0.0%)</option>
				
				<option value="file11">auth-service/infrastructure/logger/logger.go (61.6%)</option>
				
				<option value="file12">auth-service/infrastructure/repositories/mongodb_user_repository.go (0.0%)</option>
				
				<option value="file13">auth-service/infrastructure/services/jwt_token_service.go (0.0%)</option>
				
				<option value="file14">auth-service/main.go (0.0%)</option>
				
				<option value="file15">auth-service/middlewares/cors_middleware.go (0.0%)</option>
				
				<option value="file16">auth-service/middlewares/logging_middleware.go (0.0%)</option>
				
				<option value="file17">auth-service/middlewares/validation_middleware.go (0.0%)</option>
				
				<option value="file18">auth-service/test/test_config.go (95.8%)</option>
				
				<option value="file19">auth-service/usecases/login_usecase.go (90.5%)</option>
				
				<option value="file20">auth-service/usecases/validate_token_usecase.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/health": {
            "get": {
                "description": "Verifica el estado del servicio de autenticación",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Health check",
                "responses": {
                    "200": {
                        "description": "Estado del servicio",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/login": {
            "post": {
                "description": "Autentica un usuario con credenciales y devuelve un token JWT",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Autenticar usuario",
                "parameters": [
                    {
                        "description": "Credenciales de login",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/usecases.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login exitoso",
                        "schema": {
                            "$ref": "#/definitions/usecases.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Datos de entrada inválidos",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "401": {
                        "description": "Credenciales inválidas",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/public-key": {
            "get": {
                "description": "Obtiene la llave pública RSA para verificar tokens JWT",
                "produces": [
                    "application/x-pem-file"
                ],
                "tags": [
                    "tokens"
                ],
                "summary": "Obtener llave pública",
                "responses": {
                    "200": {
                        "description": "Llave pública en formato PEM",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Error interno del servidor",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/validate": {
            "post": {
                "description": "Valida un token JWT y devuelve información sobre su validez",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Validar token JWT",
                "parameters": [
                    {
                        "description": "Token a validar",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/usecases.ValidateTokenRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Validación completada",
                        "schema": {
                            "$ref": "#/definitions/usecases.ValidateTokenResponse"
                        }
                    },
                    "400": {
                        "description": "Token requerido",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "usecases.LoginRequest": {
            "description": "Credenciales de autenticación del usuario",
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "description": "@Description Contraseña del usuario\n@example password123",
                    "type": "string"
                },
                "username": {
                    "description": "@Description Nombre de usuario\n@example admin",
                    "type": "string"
                }
            }
        },
        "usecases.LoginResponse": {
            "description": "Respuesta exitosa del login con token JWT",
            "type": "object",
            "properties": {
                "token": {
                    "description": "@Description Token JWT generado para el usuario\n@example eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
                    "type": "string"
                },
                "user": {
                    "description": "@Description Nombre de usuario autenticado\n@example admin",
                    "type": "string"
                }
            }
        },
        "usecases.ValidateTokenRequest": {
            "description": "Token JWT a validar",
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "token": {
                    "description": "@Description Token JWT a validar\n@example eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
                    "type": "string"
                }
            }
        },
        "usecases.ValidateTokenResponse": {
            "description": "Resultado de la validación del token JWT",
            "type": "object",
            "properties": {
                "error": {
                    "description": "@Description Mensaje de error (solo si el token es inválido)\n@example token expired",
                    "type": "string"
                },
                "user": {
                    "description": "@Description Nombre de usuario del token (solo si es válido)\n@example admin",
                    "type": "string"
                },
                "valid": {
                    "description": "@Description Indica si el token es válido\n@example true",
                    "type": "boolean"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Auth Service API",
        Description:      "Servicio de autenticación que proporciona funcionalidades de login, validación de tokens y gestión de claves públicas.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package entities

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// TokenClaims representa los claims del token JWT
type TokenClaims struct {
        UserID   string `json:"user_id"`
        Username string `json:"username"`
        jwt.RegisteredClaims
}

// Token representa un token de autenticación
type Token struct {
        Value     string    `json:"token"`
        UserID    string    `json:"user_id"`
        Username  string    `json:"username"`
        ExpiresAt time.Time `json:"expires_at"`
        IssuedAt  time.Time `json:"issued_at"`
}

// NewToken crea una nueva instancia de Token
func NewToken(value, userID, username string, expiresAt, issuedAt time.Time) *Token <span class="cov8" title="1">{
        return &amp;Token{
                Value:     value,
                UserID:    userID,
                Username:  username,
                ExpiresAt: expiresAt,
                IssuedAt:  issuedAt,
        }
}</span>

// IsExpired verifica si el token ha expirado
func (t *Token) IsExpired() bool <span class="cov8" title="1">{
        return time.Now().After(t.ExpiresAt)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package entities

import (
        "time"

        "auth-service/infrastructure/logger"

        "github.com/google/uuid"
)

// User representa la entidad de usuario en el dominio
type User struct {
        ID        string    `json:"id"`
        Username  string    `json:"username"`
        Password  string    `json:"-"` // No se serializa en JSON
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// NewUser crea una nueva instancia de User
func NewUser(username, password string) *User <span class="cov8" title="1">{
        now := time.Now()
        return &amp;User{
                ID:        uuid.New().String(),
                Username:  username,
                Password:  password,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

// NewUserWithHashedPassword crea una nueva instancia de User con contraseña encriptada
func NewUserWithHashedPassword(username, hashedPassword string) *User <span class="cov8" title="1">{
        now := time.Now()
        return &amp;User{
                ID:        uuid.New().String(),
                Username:  username,
                Password:  hashedPassword,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

// ValidateCredentials valida las credenciales del usuario usando bcrypt
func (u *User) ValidateCredentials(password string, passwordService interface {
        ComparePassword(hashedPassword, password string) error
}) bool <span class="cov8" title="1">{
        // Agregar logging de debug
        logger.Info("Validando credenciales", map[string]interface{}{
                "username":                u.Username,
                "password_length":         len(password),
                "hashed_password_length":  len(u.Password),
                "hashed_password_preview": u.Password[:10] + "...",
        })

        err := passwordService.ComparePassword(u.Password, password)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Error comparando contraseñas", err)
        }</span> else<span class="cov8" title="1"> {
                logger.Success("Contraseñas coinciden correctamente")
        }</span>

        <span class="cov8" title="1">return err == nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package services

import (
        "golang.org/x/crypto/bcrypt"
)

// PasswordService define las operaciones para el manejo seguro de contraseñas
type PasswordService interface {
        // HashPassword encripta una contraseña usando bcrypt
        HashPassword(password string) (string, error)
        // ComparePassword compara una contraseña en texto plano con su hash
        ComparePassword(hashedPassword, password string) error
}

// DefaultPasswordService implementa PasswordService
type DefaultPasswordService struct{}

// NewDefaultPasswordService crea una nueva instancia de DefaultPasswordService
func NewDefaultPasswordService() *DefaultPasswordService <span class="cov8" title="1">{
        return &amp;DefaultPasswordService{}
}</span>

// HashPassword encripta una contraseña usando bcrypt con costo 12
func (s *DefaultPasswordService) HashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 12)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(bytes), nil</span>
}

// ComparePassword compara una contraseña en texto plano con su hash
func (s *DefaultPasswordService) ComparePassword(hashedPassword, password string) error <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}</span> </pre>
		
		<pre class="file" id="file4" style="display: none">package services

import (
        "auth-service/domain/entities"
        "auth-service/domain/repositories"
        "auth-service/infrastructure/logger"
        "time"
)

// SeedService define las operaciones para inicializar datos en la base de datos
type SeedService interface {
        // SeedDefaultUser crea el usuario por defecto si no existe
        SeedDefaultUser() error
}

// DefaultSeedService implementa SeedService
type DefaultSeedService struct {
        userRepository  repositories.UserRepository
        passwordService PasswordService
}

// NewDefaultSeedService crea una nueva instancia de DefaultSeedService
func NewDefaultSeedService(userRepository repositories.UserRepository, passwordService PasswordService) *DefaultSeedService <span class="cov8" title="1">{
        return &amp;DefaultSeedService{
                userRepository:  userRepository,
                passwordService: passwordService,
        }
}</span>

// SeedDefaultUser crea el usuario por defecto si no existe
func (s *DefaultSeedService) SeedDefaultUser() error <span class="cov8" title="1">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "DefaultSeedService.SeedDefaultUser",
                Data: map[string]interface{}{
                        "username": "admin",
                },
        })

        logger.Info("Verificando si existe usuario por defecto")

        // Verificar si el usuario admin ya existe
        exists, err := s.userRepository.Exists("admin")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error verificando existencia de usuario admin", err)
                return err
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Info("Usuario admin ya existe, verificando si necesita actualización de contraseña")

                // Obtener el usuario existente
                existingUser, err := s.userRepository.FindByUsername("admin")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error obteniendo usuario admin existente", err)
                        return err
                }</span>

                // Verificar si la contraseña ya está encriptada (bcrypt genera hashes de ~60 caracteres)
                <span class="cov8" title="1">if len(existingUser.Password) &lt; 50 </span><span class="cov8" title="1">{
                        logger.Info("Usuario admin existe pero con contraseña sin encriptar, actualizando...")

                        // Encriptar la contraseña por defecto (debe cumplir con las validaciones)
                        hashedPassword, err := s.passwordService.HashPassword("Password123!")
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Error encriptando contraseña por defecto", err)
                                return err
                        }</span>

                        // Actualizar el usuario con la contraseña encriptada
                        <span class="cov8" title="1">existingUser.Password = hashedPassword
                        existingUser.UpdatedAt = time.Now()

                        err = s.userRepository.Save(existingUser)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Error actualizando usuario admin con contraseña encriptada", err)
                                return err
                        }</span>

                        <span class="cov8" title="1">logger.Success("Usuario admin actualizado exitosamente con contraseña encriptada")</span>
                } else<span class="cov8" title="1"> {
                        logger.Info("Usuario admin ya existe con contraseña encriptada")
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        // Encriptar la contraseña por defecto (debe cumplir con las validaciones)
        <span class="cov8" title="1">hashedPassword, err := s.passwordService.HashPassword("Password123!")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error encriptando contraseña por defecto", err)
                return err
        }</span>

        // Crear usuario por defecto con contraseña encriptada
        <span class="cov8" title="1">defaultUser := entities.NewUserWithHashedPassword("admin", hashedPassword)
        err = s.userRepository.Save(defaultUser)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creando usuario admin", err)
                return err
        }</span>

        <span class="cov8" title="1">logger.Success("Usuario admin creado exitosamente con contraseña encriptada")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package validators

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/go-playground/validator/v10"
)

// CustomValidator contiene las validaciones personalizadas
type CustomValidator struct {
        validator *validator.Validate
}

// NewCustomValidator crea una nueva instancia del validador personalizado
func NewCustomValidator() *CustomValidator <span class="cov8" title="1">{
        v := validator.New()

        // Registrar validaciones personalizadas
        if err := v.RegisterValidation("username", validateUsername); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error registrando validación username: %v", err))</span>
        }
        <span class="cov8" title="1">if err := v.RegisterValidation("password", validatePassword); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error registrando validación password: %v", err))</span>
        }
        <span class="cov8" title="1">if err := v.RegisterValidation("jwt_token", validateJWTToken); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error registrando validación jwt_token: %v", err))</span>
        }
        <span class="cov8" title="1">if err := v.RegisterValidation("not_empty_string", validateNotEmptyString); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error registrando validación not_empty_string: %v", err))</span>
        }

        <span class="cov8" title="1">return &amp;CustomValidator{
                validator: v,
        }</span>
}

// Validate valida una estructura usando las reglas definidas
func (cv *CustomValidator) Validate(i interface{}) error <span class="cov8" title="1">{
        return cv.validator.Struct(i)
}</span>

// validateUsername valida el formato del nombre de usuario
func validateUsername(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        username := fl.Field().String()

        // Debe tener entre 3 y 50 caracteres
        if len(username) &lt; 3 || len(username) &gt; 50 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Solo puede contener letras, números, guiones y guiones bajos
        <span class="cov8" title="1">usernameRegex := regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)
        return usernameRegex.MatchString(username)</span>
}

// validatePassword valida el formato de la contraseña
func validatePassword(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        password := fl.Field().String()

        // Debe tener al menos 8 caracteres
        if len(password) &lt; 8 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Debe tener al menos una letra mayúscula
        <span class="cov8" title="1">hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
        if !hasUpper </span><span class="cov8" title="1">{
                return false
        }</span>

        // Debe tener al menos una letra minúscula
        <span class="cov8" title="1">hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
        if !hasLower </span><span class="cov8" title="1">{
                return false
        }</span>

        // Debe tener al menos un número
        <span class="cov8" title="1">hasNumber := regexp.MustCompile(`[0-9]`).MatchString(password)
        if !hasNumber </span><span class="cov8" title="1">{
                return false
        }</span>

        // Debe tener al menos un carácter especial
        <span class="cov8" title="1">hasSpecial := regexp.MustCompile(`[!@#$%^&amp;*()_+\-=\[\]{};':"\\|,.&lt;&gt;\/?]`).MatchString(password)
        if !hasSpecial </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// validateJWTToken valida el formato básico de un token JWT
func validateJWTToken(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        token := fl.Field().String()

        // Un token JWT debe tener 3 partes separadas por puntos
        parts := strings.Split(token, ".")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Cada parte debe tener contenido
        <span class="cov8" title="1">for _, part := range parts </span><span class="cov8" title="1">{
                if len(strings.TrimSpace(part)) == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// validateNotEmptyString valida que el string no esté vacío después de trim
func validateNotEmptyString(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        value := strings.TrimSpace(fl.Field().String())
        return len(value) &gt; 0
}</span>

// GetValidationErrors traduce los errores de validación a mensajes en español
func GetValidationErrors(err error) map[string]string <span class="cov8" title="1">{
        errors := make(map[string]string)

        if validationErrors, ok := err.(validator.ValidationErrors); ok </span><span class="cov8" title="1">{
                for _, e := range validationErrors </span><span class="cov8" title="1">{
                        field := e.Field()
                        tag := e.Tag()
                        param := e.Param()

                        message := getErrorMessage(field, tag, param)
                        errors[field] = message
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

// getErrorMessage devuelve el mensaje de error en español para cada tipo de validación
func getErrorMessage(field, tag, param string) string <span class="cov8" title="1">{
        switch tag </span>{
        case "required":<span class="cov0" title="0">
                return fmt.Sprintf("El campo %s es obligatorio", field)</span>
        case "username":<span class="cov8" title="1">
                return fmt.Sprintf("El campo %s debe tener entre 3 y 50 caracteres y solo puede contener letras, números, guiones y guiones bajos", field)</span>
        case "password":<span class="cov8" title="1">
                return fmt.Sprintf("El campo %s debe tener al menos 8 caracteres, incluyendo mayúsculas, minúsculas, números y caracteres especiales", field)</span>
        case "jwt_token":<span class="cov8" title="1">
                return fmt.Sprintf("El campo %s debe ser un token JWT válido", field)</span>
        case "not_empty_string":<span class="cov8" title="1">
                return fmt.Sprintf("El campo %s no puede estar vacío", field)</span>
        case "min":<span class="cov0" title="0">
                return fmt.Sprintf("El campo %s debe tener al menos %s caracteres", field, param)</span>
        case "max":<span class="cov0" title="0">
                return fmt.Sprintf("El campo %s debe tener máximo %s caracteres", field, param)</span>
        case "email":<span class="cov0" title="0">
                return fmt.Sprintf("El campo %s debe ser un email válido", field)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("El campo %s no cumple con la validación requerida", field)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "net/http"

        "auth-service/infrastructure/logger"
        "auth-service/middlewares"
        "auth-service/usecases"

        "github.com/gin-gonic/gin"
)

// AuthController maneja las peticiones HTTP relacionadas con autenticación
type AuthController struct {
        loginUseCase         *usecases.LoginUseCase
        validateTokenUseCase *usecases.ValidateTokenUseCase
        validationMiddleware *middlewares.ValidationMiddleware
}

// NewAuthController crea una nueva instancia de AuthController
func NewAuthController(
        loginUseCase *usecases.LoginUseCase,
        validateTokenUseCase *usecases.ValidateTokenUseCase,
) *AuthController <span class="cov0" title="0">{
        return &amp;AuthController{
                loginUseCase:         loginUseCase,
                validateTokenUseCase: validateTokenUseCase,
                validationMiddleware: middlewares.NewValidationMiddleware(),
        }
}</span>

// Login maneja la petición de login
// @Summary Autenticar usuario
// @Description Autentica un usuario con credenciales y devuelve un token JWT
// @Tags auth
// @Accept json
// @Produce json
// @Param request body usecases.LoginRequest true "Credenciales de login"
// @Success 200 {object} usecases.LoginResponse "Login exitoso"
// @Failure 400 {object} map[string]interface{} "Datos de entrada inválidos"
// @Failure 401 {object} map[string]interface{} "Credenciales inválidas"
// @Router /login [post]
func (c *AuthController) Login(ctx *gin.Context) <span class="cov0" title="0">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "AuthController.Login",
                Data: map[string]interface{}{
                        "endpoint": "/login",
                },
        })

        logger.Info("Iniciando proceso de login")

        // Obtener la request validada del middleware
        validatedRequest, exists := ctx.Get("validated_request")
        if !exists </span><span class="cov0" title="0">{
                logger.Error("Request no validada encontrada", nil)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Error interno del servidor"})
                return
        }</span>

        // Hacer type assertion correcta para el puntero
        <span class="cov0" title="0">requestPtr, ok := validatedRequest.(*usecases.LoginRequest)
        if !ok </span><span class="cov0" title="0">{
                logger.Error("Tipo de request inválido", nil)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Error interno del servidor"})
                return
        }</span>
        <span class="cov0" title="0">request := *requestPtr

        logger.Info("Datos de login recibidos", map[string]interface{}{
                "username": request.Username,
        })

        response, err := c.loginUseCase.Execute(request)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error en proceso de login", err)
                ctx.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">logger.Success("Login exitoso", map[string]interface{}{
                "username": request.Username,
        })

        ctx.JSON(http.StatusOK, response)</span>
}

// ValidateToken maneja la petición de validación de token
// @Summary Validar token JWT
// @Description Valida un token JWT y devuelve información sobre su validez
// @Tags auth
// @Accept json
// @Produce json
// @Param request body usecases.ValidateTokenRequest true "Token a validar"
// @Success 200 {object} usecases.ValidateTokenResponse "Validación completada"
// @Failure 400 {object} map[string]interface{} "Token requerido"
// @Router /validate [post]
func (c *AuthController) ValidateToken(ctx *gin.Context) <span class="cov0" title="0">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "AuthController.ValidateToken",
                Data: map[string]interface{}{
                        "endpoint": "/validate",
                },
        })

        logger.Info("Iniciando validación de token")

        // Obtener la request validada del middleware
        validatedRequest, exists := ctx.Get("validated_request")
        if !exists </span><span class="cov0" title="0">{
                logger.Error("Request no validada encontrada", nil)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Error interno del servidor"})
                return
        }</span>

        // Hacer type assertion correcta para el puntero
        <span class="cov0" title="0">requestPtr, ok := validatedRequest.(*usecases.ValidateTokenRequest)
        if !ok </span><span class="cov0" title="0">{
                logger.Error("Tipo de request inválido", nil)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Error interno del servidor"})
                return
        }</span>
        <span class="cov0" title="0">request := *requestPtr

        logger.Info("Token recibido para validación", map[string]interface{}{
                "token_length": len(request.Token),
        })

        response := c.validateTokenUseCase.Execute(request)

        logger.Success("Validación de token completada", map[string]interface{}{
                "valid": response.Valid,
        })

        ctx.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "auth-service/domain/services"
        "auth-service/infrastructure/logger"
        "net/http"

        "github.com/gin-gonic/gin"
)

// HealthController maneja las peticiones HTTP relacionadas con health check
type HealthController struct {
        seedService services.SeedService
}

// NewHealthController crea una nueva instancia de HealthController
func NewHealthController(seedService services.SeedService) *HealthController <span class="cov0" title="0">{
        return &amp;HealthController{
                seedService: seedService,
        }
}</span>

// Health maneja la petición de health check
// @Summary Health check
// @Description Verifica el estado del servicio de autenticación y ejecuta semilla de datos
// @Tags health
// @Produce json
// @Success 200 {object} map[string]interface{} "Estado del servicio"
// @Failure 500 {object} map[string]interface{} "Error interno del servidor"
// @Router /health [get]
func (c *HealthController) Health(ctx *gin.Context) <span class="cov0" title="0">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "HealthController.Health",
                Data: map[string]interface{}{
                        "endpoint": "/health",
                },
        })

        logger.Info("Health check solicitado")

        // Ejecutar semilla de datos
        err := c.seedService.SeedDefaultUser()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error ejecutando semilla de datos", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{
                        "status":  "error",
                        "service": "auth-service",
                        "message": "Error ejecutando semilla de datos",
                })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "status":  "ok",
                "service": "auth-service",
                "message": "Servicio funcionando correctamente y semilla ejecutada",
        })

        logger.Success("Health check completado exitosamente")</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "auth-service/middlewares"
        "auth-service/usecases"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

// SetupRoutes configura las rutas de la aplicación
func SetupRoutes(
        authController *AuthController,
        tokenController *TokenController,
        healthController *HealthController,
) *gin.Engine <span class="cov0" title="0">{
        router := gin.Default()

        // Aplicar middleware de logging primero
        router.Use(middlewares.LoggingMiddleware())

        // Aplicar middleware CORS
        router.Use(middlewares.CORSMiddleware())

        // Ruta de documentación Swagger
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Rutas de autenticación con validación
        router.POST("/login", authController.validationMiddleware.ValidateRequest(&amp;usecases.LoginRequest{}), authController.Login)
        router.POST("/validate", authController.validationMiddleware.ValidateRequest(&amp;usecases.ValidateTokenRequest{}), authController.ValidateToken)

        // Rutas de tokens
        router.GET("/public-key", tokenController.GetPublicKey)

        // Rutas de health
        router.GET("/health", healthController.Health)

        return router
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "net/http"

        "auth-service/domain/services"
        "auth-service/infrastructure/logger"

        "github.com/gin-gonic/gin"
)

// TokenController maneja las peticiones HTTP relacionadas con tokens
type TokenController struct {
        tokenService services.TokenService
}

// NewTokenController crea una nueva instancia de TokenController
func NewTokenController(tokenService services.TokenService) *TokenController <span class="cov0" title="0">{
        return &amp;TokenController{
                tokenService: tokenService,
        }
}</span>

// GetPublicKey maneja la petición para obtener la llave pública
// @Summary Obtener llave pública
// @Description Obtiene la llave pública RSA para verificar tokens JWT
// @Tags tokens
// @Produce application/x-pem-file
// @Success 200 {string} string "Llave pública en formato PEM"
// @Failure 500 {object} map[string]interface{} "Error interno del servidor"
// @Router /public-key [get]
func (c *TokenController) GetPublicKey(ctx *gin.Context) <span class="cov0" title="0">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "TokenController.GetPublicKey",
                Data: map[string]interface{}{
                        "endpoint": "/public-key",
                },
        })

        logger.Info("Solicitud de llave pública recibida")

        publicKey, err := c.tokenService.GetPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error al obtener llave pública", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Error serializando llave pública"})
                return
        }</span>

        <span class="cov0" title="0">logger.Success("Llave pública enviada exitosamente", map[string]interface{}{
                "public_key_length": len(publicKey),
        })

        ctx.Data(http.StatusOK, "application/x-pem-file", []byte(publicKey))</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package di

import (
        domainRepos "auth-service/domain/repositories"
        domainServices "auth-service/domain/services"
        "auth-service/entrypoints/api"
        infraRepos "auth-service/infrastructure/repositories"
        infraServices "auth-service/infrastructure/services"
        "auth-service/usecases"
        "os"
)

// Container maneja la inyección de dependencias
type Container struct {
        UserRepository       domainRepos.UserRepository
        TokenService         domainServices.TokenService
        PasswordService      domainServices.PasswordService
        SeedService          domainServices.SeedService
        LoginUseCase         *usecases.LoginUseCase
        ValidateTokenUseCase *usecases.ValidateTokenUseCase
        AuthController       *api.AuthController
        TokenController      *api.TokenController
        HealthController     *api.HealthController
}

// NewContainer crea una nueva instancia del contenedor de dependencias
func NewContainer() (*Container, error) <span class="cov0" title="0">{
        // Obtener configuración de MongoDB desde variables de entorno
        mongoURI := os.Getenv("MONGO_URI")
        if mongoURI == "" </span><span class="cov0" title="0">{
                mongoURI = "mongodb://localhost:27017"
        }</span>

        <span class="cov0" title="0">databaseName := os.Getenv("MONGO_DATABASE")
        if databaseName == "" </span><span class="cov0" title="0">{
                databaseName = "auth_service"
        }</span>

        // Crear repositorio de MongoDB
        <span class="cov0" title="0">userRepo, err := infraRepos.NewMongoDBUserRepository(mongoURI, databaseName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Crear servicios
        <span class="cov0" title="0">tokenService, err := infraServices.NewJWTTokenService()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">passwordService := domainServices.NewDefaultPasswordService()
        seedService := domainServices.NewDefaultSeedService(userRepo, passwordService)

        // Crear casos de uso
        loginUseCase := usecases.NewLoginUseCase(userRepo, tokenService, passwordService)
        validateTokenUseCase := usecases.NewValidateTokenUseCase(tokenService)

        // Crear controladores
        authController := api.NewAuthController(loginUseCase, validateTokenUseCase)
        tokenController := api.NewTokenController(tokenService)
        healthController := api.NewHealthController(seedService)

        return &amp;Container{
                UserRepository:       userRepo,
                TokenService:         tokenService,
                PasswordService:      passwordService,
                SeedService:          seedService,
                LoginUseCase:         loginUseCase,
                ValidateTokenUseCase: validateTokenUseCase,
                AuthController:       authController,
                TokenController:      tokenController,
                HealthController:     healthController,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package logger

import (
        "os"
        "path/filepath"
        "runtime"
        "time"

        "github.com/fatih/color"
        "github.com/sirupsen/logrus"
)

// Context representa el contexto de la operación
type Context struct {
        FunctionName string                 `json:"functionName"`
        Data         map[string]interface{} `json:"data,omitempty"`
}

// Logger es la estructura principal del logger
type Logger struct {
        logger *logrus.Logger
        file   *os.File
}

var (
        instance *Logger
        context  Context
)

// GetInstance retorna la instancia singleton del logger
func GetInstance() *Logger <span class="cov8" title="1">{
        if instance == nil </span><span class="cov8" title="1">{
                instance = &amp;Logger{
                        logger: logrus.New(),
                }
                instance.setupLogger()
        }</span>
        <span class="cov8" title="1">return instance</span>
}

// setupLogger configura el logger con formato JSON y archivo de salida
func (l *Logger) setupLogger() <span class="cov8" title="1">{
        // Crear directorio de logs si no existe
        logDir := "logs"
        if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                panic("No se pudo crear el directorio de logs: " + err.Error())</span>
        }

        // Abrir archivo de log
        <span class="cov8" title="1">logFile := filepath.Join(logDir, "auth-service.log")
        file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                panic("No se pudo abrir el archivo de log: " + err.Error())</span>
        }

        <span class="cov8" title="1">l.file = file
        l.logger.SetOutput(file)
        l.logger.SetFormatter(&amp;logrus.JSONFormatter{
                TimestampFormat: time.RFC3339,
                FieldMap: logrus.FieldMap{
                        logrus.FieldKeyTime:  "timestamp",
                        logrus.FieldKeyLevel: "level",
                        logrus.FieldKeyMsg:   "message",
                },
        })
        l.logger.SetLevel(logrus.InfoLevel)</span>
}

// SetContext establece el contexto para los logs
func SetContext(ctx Context) <span class="cov8" title="1">{
        context = ctx
}</span>

// AddContext agrega datos adicionales al contexto existente
func AddContext(data map[string]interface{}) <span class="cov0" title="0">{
        if context.Data == nil </span><span class="cov0" title="0">{
                context.Data = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">for k, v := range data </span><span class="cov0" title="0">{
                context.Data[k] = v
        }</span>
}

// getCallerInfo obtiene información de la función que llama al logger
func getCallerInfo() string <span class="cov8" title="1">{
        pc, _, _, ok := runtime.Caller(2)
        if ok </span><span class="cov8" title="1">{
                fn := runtime.FuncForPC(pc)
                if fn != nil </span><span class="cov8" title="1">{
                        return fn.Name()
                }</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}

// Info registra un mensaje de información
func Info(message string, data ...map[string]interface{}) <span class="cov8" title="1">{
        logger := GetInstance()
        fields := logrus.Fields{
                "context": context,
                "caller":  getCallerInfo(),
        }

        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                for k, v := range data[0] </span><span class="cov8" title="1">{
                        fields[k] = v
                }</span>
        }

        // Log a archivo
        <span class="cov8" title="1">logger.logger.WithFields(fields).Info(message)

        // Log a consola con color
        color.Blue("[INFO] %s", message)
        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                color.Cyan("  Data: %+v", data[0])
        }</span>
}

// Error registra un mensaje de error
func Error(message string, err error) <span class="cov8" title="1">{
        logger := GetInstance()
        fields := logrus.Fields{
                "context": context,
                "caller":  getCallerInfo(),
        }

        if err != nil </span><span class="cov8" title="1">{
                fields["error"] = err.Error()
        }</span>

        // Log a archivo
        <span class="cov8" title="1">logger.logger.WithFields(fields).Error(message)

        // Log a consola con color
        color.Red("[ERROR] %s", message)
        if err != nil </span><span class="cov8" title="1">{
                color.Red("  Error: %v", err)
        }</span>
}

// Warn registra un mensaje de advertencia
func Warn(message string, data ...map[string]interface{}) <span class="cov0" title="0">{
        logger := GetInstance()
        fields := logrus.Fields{
                "context": context,
                "caller":  getCallerInfo(),
        }

        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range data[0] </span><span class="cov0" title="0">{
                        fields[k] = v
                }</span>
        }

        // Log a archivo
        <span class="cov0" title="0">logger.logger.WithFields(fields).Warn(message)

        // Log a consola con color
        color.Yellow("[WARN] %s", message)
        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                color.Yellow("  Data: %+v", data[0])
        }</span>
}

// Debug registra un mensaje de debug
func Debug(message string, data ...map[string]interface{}) <span class="cov0" title="0">{
        logger := GetInstance()
        fields := logrus.Fields{
                "context": context,
                "caller":  getCallerInfo(),
        }

        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range data[0] </span><span class="cov0" title="0">{
                        fields[k] = v
                }</span>
        }

        // Log a archivo
        <span class="cov0" title="0">logger.logger.WithFields(fields).Debug(message)

        // Log a consola con color
        color.White("[DEBUG] %s", message)
        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                color.White("  Data: %+v", data[0])
        }</span>
}

// Success registra un mensaje de éxito
func Success(message string, data ...map[string]interface{}) <span class="cov8" title="1">{
        logger := GetInstance()
        fields := logrus.Fields{
                "context": context,
                "caller":  getCallerInfo(),
        }

        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                for k, v := range data[0] </span><span class="cov8" title="1">{
                        fields[k] = v
                }</span>
        }

        // Log a archivo como info
        <span class="cov8" title="1">logger.logger.WithFields(fields).Info(message)

        // Log a consola con color verde
        color.Green("[SUCCESS] %s", message)
        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                color.Green("  Data: %+v", data[0])
        }</span>
}

// Close cierra el archivo de log
func (l *Logger) Close() error <span class="cov0" title="0">{
        if l.file != nil </span><span class="cov0" title="0">{
                return l.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package repositories

import (
        "auth-service/domain/entities"
        "auth-service/domain/repositories"
        "auth-service/infrastructure/logger"
        "context"
        "errors"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// MongoDBUserRepository implementa UserRepository usando MongoDB
type MongoDBUserRepository struct {
        client     *mongo.Client
        database   *mongo.Database
        collection *mongo.Collection
}

// UserDocument representa el documento de usuario en MongoDB
type UserDocument struct {
        ID        primitive.ObjectID `bson:"_id,omitempty"`
        Username  string             `bson:"username"`
        Password  string             `bson:"password"`
        CreatedAt time.Time          `bson:"created_at"`
        UpdatedAt time.Time          `bson:"updated_at"`
}

// NewMongoDBUserRepository crea una nueva instancia de MongoDBUserRepository
func NewMongoDBUserRepository(mongoURI, databaseName string) (*MongoDBUserRepository, error) <span class="cov0" title="0">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "NewMongoDBUserRepository",
                Data: map[string]interface{}{
                        "mongoURI":     mongoURI,
                        "databaseName": databaseName,
                },
        })

        logger.Info("Conectando a MongoDB")

        // Conectar a MongoDB
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        client, err := mongo.Connect(ctx, options.Client().ApplyURI(mongoURI))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error conectando a MongoDB", err)
                return nil, err
        }</span>

        // Verificar conexión
        <span class="cov0" title="0">err = client.Ping(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error verificando conexión a MongoDB", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">database := client.Database(databaseName)
        collection := database.Collection("users")

        // Crear índice único en username
        indexModel := mongo.IndexModel{
                Keys:    bson.D{{Key: "username", Value: 1}},
                Options: options.Index().SetUnique(true),
        }

        _, err = collection.Indexes().CreateOne(ctx, indexModel)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creando índice en MongoDB", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Success("Conexión a MongoDB establecida correctamente")

        return &amp;MongoDBUserRepository{
                client:     client,
                database:   database,
                collection: collection,
        }, nil</span>
}

// Close cierra la conexión a MongoDB
func (r *MongoDBUserRepository) Close() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        return r.client.Disconnect(ctx)
}</span>

// FindByUsername busca un usuario por su nombre de usuario
func (r *MongoDBUserRepository) FindByUsername(username string) (*entities.User, error) <span class="cov0" title="0">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "MongoDBUserRepository.FindByUsername",
                Data: map[string]interface{}{
                        "username": username,
                },
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        var userDoc UserDocument
        err := r.collection.FindOne(ctx, bson.M{"username": username}).Decode(&amp;userDoc)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        logger.Info("Usuario no encontrado en MongoDB")
                        return nil, errors.New("usuario no encontrado")
                }</span>
                <span class="cov0" title="0">logger.Error("Error buscando usuario en MongoDB", err)
                return nil, err</span>
        }

        <span class="cov0" title="0">user := &amp;entities.User{
                ID:        userDoc.ID.Hex(),
                Username:  userDoc.Username,
                Password:  userDoc.Password,
                CreatedAt: userDoc.CreatedAt,
                UpdatedAt: userDoc.UpdatedAt,
        }

        logger.Success("Usuario encontrado en MongoDB")
        return user, nil</span>
}

// Save guarda un usuario en el repositorio
func (r *MongoDBUserRepository) Save(user *entities.User) error <span class="cov0" title="0">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "MongoDBUserRepository.Save",
                Data: map[string]interface{}{
                        "username": user.Username,
                },
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Verificar si el usuario ya existe
        existingUser, err := r.FindByUsername(user.Username)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                // Usuario existe, actualizar
                objectID, err := primitive.ObjectIDFromHex(existingUser.ID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error convirtiendo ID a ObjectID", err)
                        return err
                }</span>

                <span class="cov0" title="0">userDoc := UserDocument{
                        ID:        objectID,
                        Username:  user.Username,
                        Password:  user.Password,
                        CreatedAt: existingUser.CreatedAt,
                        UpdatedAt: time.Now(),
                }

                _, err = r.collection.ReplaceOne(ctx, bson.M{"_id": objectID}, userDoc)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error actualizando usuario en MongoDB", err)
                        return err
                }</span>

                <span class="cov0" title="0">logger.Success("Usuario actualizado en MongoDB")
                return nil</span>
        }

        // Usuario no existe, crear nuevo
        <span class="cov0" title="0">userDoc := UserDocument{
                Username:  user.Username,
                Password:  user.Password,
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
        }

        result, err := r.collection.InsertOne(ctx, userDoc)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error guardando usuario en MongoDB", err)
                return err
        }</span>

        // Actualizar el ID del usuario con el ObjectID generado por MongoDB
        <span class="cov0" title="0">if oid, ok := result.InsertedID.(primitive.ObjectID); ok </span><span class="cov0" title="0">{
                user.ID = oid.Hex()
        }</span>

        <span class="cov0" title="0">logger.Success("Usuario guardado en MongoDB")
        return nil</span>
}

// Exists verifica si existe un usuario con el username dado
func (r *MongoDBUserRepository) Exists(username string) (bool, error) <span class="cov0" title="0">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "MongoDBUserRepository.Exists",
                Data: map[string]interface{}{
                        "username": username,
                },
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        count, err := r.collection.CountDocuments(ctx, bson.M{"username": username})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error verificando existencia de usuario en MongoDB", err)
                return false, err
        }</span>

        <span class="cov0" title="0">exists := count &gt; 0
        logger.Info("Verificación de existencia de usuario completada", map[string]interface{}{
                "exists": exists,
        })

        return exists, nil</span>
}

// Ensure MongoDBUserRepository implementa UserRepository
var _ repositories.UserRepository = (*MongoDBUserRepository)(nil) </pre>
		
		<pre class="file" id="file13" style="display: none">package services

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "log"
        "os"
        "time"

        "auth-service/domain/entities"
        "auth-service/domain/services"

        "github.com/golang-jwt/jwt/v5"
)

// JWTTokenService implementa TokenService usando JWT
type JWTTokenService struct {
        privateKey *rsa.PrivateKey
        publicKey  *rsa.PublicKey
}

// NewJWTTokenService crea una nueva instancia de JWTTokenService
func NewJWTTokenService() (*JWTTokenService, error) <span class="cov0" title="0">{
        privateKey, publicKey, err := generateOrLoadKeys()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;JWTTokenService{
                privateKey: privateKey,
                publicKey:  publicKey,
        }, nil</span>
}

// GenerateToken genera un nuevo token para un usuario
func (s *JWTTokenService) GenerateToken(user *entities.User) (*entities.Token, error) <span class="cov0" title="0">{
        now := time.Now()
        expiresAt := now.Add(24 * time.Hour)

        claims := entities.TokenClaims{
                UserID:   user.ID,
                Username: user.Username,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    "auth-service",
                        Subject:   user.ID,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        tokenString, err := token.SignedString(s.privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entities.NewToken(tokenString, user.ID, user.Username, expiresAt, now), nil</span>
}

// ValidateToken valida un token y retorna los claims
func (s *JWTTokenService) ValidateToken(tokenString string) (*entities.TokenClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;entities.TokenClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("método de firma inesperado: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return s.publicKey, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*entities.TokenClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("token inválido")</span>
}

// GetPublicKey retorna la llave pública para validación
func (s *JWTTokenService) GetPublicKey() (string, error) <span class="cov0" title="0">{
        publicKeyBytes, err := x509.MarshalPKIXPublicKey(s.publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: publicKeyBytes,
        })
        
        return string(publicKeyPEM), nil</span>
}

// generateOrLoadKeys genera o carga las llaves RSA
func generateOrLoadKeys() (*rsa.PrivateKey, *rsa.PublicKey, error) <span class="cov0" title="0">{
        // Intentar cargar llaves existentes
        privateKeyBytes, err := os.ReadFile("private.pem")
        if err == nil </span><span class="cov0" title="0">{
                publicKeyBytes, err := os.ReadFile("public.pem")
                if err == nil </span><span class="cov0" title="0">{
                        // Decodificar llave privada
                        block, _ := pem.Decode(privateKeyBytes)
                        privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>

                        // Decodificar llave pública
                        <span class="cov0" title="0">block, _ = pem.Decode(publicKeyBytes)
                        publicKey, err := x509.ParsePKIXPublicKey(block.Bytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>

                        <span class="cov0" title="0">return privateKey, publicKey.(*rsa.PublicKey), nil</span>
                }
        }

        // Generar nuevas llaves
        <span class="cov0" title="0">log.Println("Generando nuevas llaves RSA...")
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">publicKey := &amp;privateKey.PublicKey

        // Guardar llave privada
        privateKeyPEM := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        }
        err = os.WriteFile("private.pem", pem.EncodeToMemory(privateKeyPEM), 0600)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Guardar llave pública
        <span class="cov0" title="0">publicKeyBytes, err := x509.MarshalPKIXPublicKey(publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">publicKeyPEM := &amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: publicKeyBytes,
        }
        err = os.WriteFile("public.pem", pem.EncodeToMemory(publicKeyPEM), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Llaves RSA generadas y guardadas")
        return privateKey, publicKey, nil</span>
}

// Ensure JWTTokenService implementa TokenService
var _ services.TokenService = (*JWTTokenService)(nil) </pre>
		
		<pre class="file" id="file14" style="display: none">// Package main Auth Service API
//
// Servicio de autenticación que proporciona funcionalidades de login, validación de tokens y gestión de claves públicas.
//
//        Schemes: http, https
//        Host: localhost:8080
//        BasePath: /
//        Version: 1.0.0
//
//        Consumes:
//        - application/json
//
//        Produces:
//        - application/json
//        - application/x-pem-file
//
//        Security:
//        - bearer
//
// swagger:meta
package main

import (
        "log"
        "net/http"
        "os"

        "auth-service/entrypoints/api"
        "auth-service/infrastructure/di"
        "auth-service/infrastructure/logger"
        infraRepos "auth-service/infrastructure/repositories"

        _ "auth-service/docs" // Importar documentación generada por swag
)

// @title Auth Service API
// @version 1.0
// @description Servicio de autenticación que proporciona funcionalidades de login, validación de tokens y gestión de claves públicas.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() <span class="cov0" title="0">{
        // Inicializar logger
        loggerInstance := logger.GetInstance()
        defer loggerInstance.Close()

        // Establecer contexto inicial
        logger.SetContext(logger.Context{
                FunctionName: "main",
                Data: map[string]interface{}{
                        "service": "auth-service",
                },
        })

        logger.Info("Iniciando servicio de autenticación")

        // Crear contenedor de dependencias
        container, err := di.NewContainer()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error inicializando contenedor de dependencias", err)
                log.Fatal("Error inicializando contenedor de dependencias:", err)
        }</span>

        // Cerrar conexión de MongoDB al finalizar
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if mongoRepo, ok := container.UserRepository.(*infraRepos.MongoDBUserRepository); ok </span><span class="cov0" title="0">{
                        if err := mongoRepo.Close(); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Error cerrando conexión de MongoDB", err)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Success("Conexión de MongoDB cerrada correctamente")
                        }</span>
                }
        }()

        <span class="cov0" title="0">logger.Success("Contenedor de dependencias inicializado correctamente")

        // Configurar rutas
        router := api.SetupRoutes(
                container.AuthController,
                container.TokenController,
                container.HealthController,
        )

        logger.Success("Rutas configuradas correctamente")

        // Obtener puerto del entorno
        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">logger.Info("Servicio listo para recibir peticiones", map[string]interface{}{
                "port": port,
        })

        logger.Success("Servicio de autenticación iniciando en puerto " + port)
        log.Fatal(http.ListenAndServe(":"+port, router))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middlewares

import (
        "github.com/gin-gonic/gin"
        "github.com/rs/cors"
)

// CORSMiddleware configura CORS para la aplicación
func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        config := cors.New(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowedMethods:   []string{"GET", "POST"},
                AllowedHeaders:   []string{"*"},
                AllowCredentials: true,
        })

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                config.HandlerFunc(c.Writer, c.Request)
                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
} </pre>
		
		<pre class="file" id="file16" style="display: none">package middlewares

import (
        "bytes"
        "io"
        "time"

        "auth-service/infrastructure/logger"

        "github.com/gin-gonic/gin"
)

// responseWriter es un wrapper para capturar la respuesta
type responseWriter struct {
        gin.ResponseWriter
        body *bytes.Buffer
}

func (w responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>

// LoggingMiddleware registra todas las peticiones HTTP
func LoggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Capturar el cuerpo de la petición de manera segura
                var requestBody []byte
                if c.Request.Body != nil </span><span class="cov0" title="0">{
                        // Leer el body una sola vez
                        requestBody, _ = io.ReadAll(c.Request.Body)
                        // Restaurar el body para que otros middlewares puedan leerlo
                        c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
                }</span>

                // Crear wrapper para capturar la respuesta
                <span class="cov0" title="0">blw := &amp;responseWriter{
                        ResponseWriter: c.Writer,
                        body:           bytes.NewBufferString(""),
                }
                c.Writer = blw

                // Establecer contexto para el logger
                logger.SetContext(logger.Context{
                        FunctionName: "HTTP_Request",
                        Data: map[string]interface{}{
                                "method":     c.Request.Method,
                                "path":       c.Request.URL.Path,
                                "user_agent": c.Request.UserAgent(),
                                "ip":         c.ClientIP(),
                        },
                })

                // Log de inicio de petición
                logger.Info("Iniciando petición HTTP", map[string]interface{}{
                        "request_body": string(requestBody),
                })

                // Procesar la petición
                c.Next()

                // Calcular duración
                duration := time.Since(start)

                // Log de fin de petición
                statusCode := c.Writer.Status()

                logData := map[string]interface{}{
                        "status_code":   statusCode,
                        "duration":      duration.String(),
                        "response_size": len(blw.body.String()),
                }

                if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        logger.Error("Petición HTTP completada con error", nil)
                }</span> else<span class="cov0" title="0"> {
                        logger.Success("Petición HTTP completada exitosamente", logData)
                }</span>

                // Log detallado de errores si los hay
                <span class="cov0" title="0">if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range c.Errors </span><span class="cov0" title="0">{
                                logger.Error("Error en petición HTTP", err.Err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package middlewares

import (
        "auth-service/domain/validators"
        "auth-service/infrastructure/logger"
        "net/http"
        "reflect"

        "github.com/gin-gonic/gin"
)

// ValidationMiddleware es un middleware que valida los datos de entrada
type ValidationMiddleware struct {
        validator *validators.CustomValidator
}

// NewValidationMiddleware crea una nueva instancia del middleware de validación
func NewValidationMiddleware() *ValidationMiddleware <span class="cov0" title="0">{
        return &amp;ValidationMiddleware{
                validator: validators.NewCustomValidator(),
        }
}</span>

// ValidateRequest es un middleware que valida automáticamente las estructuras de request
func (vm *ValidationMiddleware) ValidateRequest(requestType interface{}) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // No establecer contexto aquí para evitar conflictos con el middleware de logging
                logger.Info("Iniciando validación de datos de entrada")

                // Crear una nueva instancia del tipo de request usando reflexión
                requestTypeValue := reflect.ValueOf(requestType)
                if requestTypeValue.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        requestTypeValue = requestTypeValue.Elem()
                }</span>
                <span class="cov0" title="0">request := reflect.New(requestTypeValue.Type()).Interface()

                // Parsear el JSON del body
                if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error al parsear JSON", err)
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "Formato JSON inválido",
                                "details": err.Error(),
                        })
                        c.Abort()
                        return
                }</span>

                // Validar la estructura
                <span class="cov0" title="0">if err := vm.validator.Validate(request); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error de validación", err)
                        validationErrors := validators.GetValidationErrors(err)

                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "Datos de entrada inválidos",
                                "details": validationErrors,
                        })
                        c.Abort()
                        return
                }</span>

                // Guardar la request validada en el contexto para uso posterior
                <span class="cov0" title="0">c.Set("validated_request", request)

                logger.Success("Validación de datos completada exitosamente")

                c.Next()</span>
        }
}

// ValidateQueryParams valida los parámetros de query
func (vm *ValidationMiddleware) ValidateQueryParams(requiredParams []string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                logger.Info("Validando parámetros de query")

                missingParams := []string{}
                for _, param := range requiredParams </span><span class="cov0" title="0">{
                        if c.Query(param) == "" </span><span class="cov0" title="0">{
                                missingParams = append(missingParams, param)
                        }</span>
                }

                <span class="cov0" title="0">if len(missingParams) &gt; 0 </span><span class="cov0" title="0">{
                        logger.Error("Parámetros de query faltantes", nil)
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "Parámetros de query requeridos",
                                "details": map[string]interface{}{
                                        "missing_params": missingParams,
                                },
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">logger.Success("Validación de parámetros de query completada")
                c.Next()</span>
        }
}

// ValidateHeaders valida los headers requeridos
func (vm *ValidationMiddleware) ValidateHeaders(requiredHeaders []string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                logger.Info("Validando headers requeridos")

                missingHeaders := []string{}
                for _, header := range requiredHeaders </span><span class="cov0" title="0">{
                        if c.GetHeader(header) == "" </span><span class="cov0" title="0">{
                                missingHeaders = append(missingHeaders, header)
                        }</span>
                }

                <span class="cov0" title="0">if len(missingHeaders) &gt; 0 </span><span class="cov0" title="0">{
                        logger.Error("Headers requeridos faltantes", nil)
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "Headers requeridos",
                                "details": map[string]interface{}{
                                        "missing_headers": missingHeaders,
                                },
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">logger.Success("Validación de headers completada")
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package test

import (
        "auth-service/domain/entities"
        "auth-service/domain/repositories"
        "auth-service/domain/services"
        "auth-service/usecases"
        "errors"
)

// TestConfig proporciona configuración y mocks para los tests
type TestConfig struct {
        UserRepository  repositories.UserRepository
        TokenService    services.TokenService
        PasswordService services.PasswordService
        SeedService     services.SeedService
        LoginUseCase    *usecases.LoginUseCase
}

// NewTestConfig crea una nueva configuración de test con mocks
func NewTestConfig() *TestConfig <span class="cov8" title="1">{
        userRepo := NewMockUserRepository()
        tokenService := NewMockTokenService()
        passwordService := services.NewDefaultPasswordService()
        seedService := services.NewDefaultSeedService(userRepo, passwordService)
        loginUseCase := usecases.NewLoginUseCase(userRepo, tokenService, passwordService)

        return &amp;TestConfig{
                UserRepository:  userRepo,
                TokenService:    tokenService,
                PasswordService: passwordService,
                SeedService:     seedService,
                LoginUseCase:    loginUseCase,
        }
}</span>

// MockUserRepository implementa UserRepository para testing
type MockUserRepository struct {
        users map[string]*entities.User
}

func NewMockUserRepository() *MockUserRepository <span class="cov8" title="1">{
        return &amp;MockUserRepository{
                users: make(map[string]*entities.User),
        }
}</span>

func (m *MockUserRepository) Save(user *entities.User) error <span class="cov8" title="1">{
        m.users[user.Username] = user
        return nil
}</span>

func (m *MockUserRepository) FindByUsername(username string) (*entities.User, error) <span class="cov8" title="1">{
        user, exists := m.users[username]
        if !exists </span><span class="cov8" title="1">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

func (m *MockUserRepository) Exists(username string) (bool, error) <span class="cov8" title="1">{
        _, exists := m.users[username]
        return exists, nil
}</span>

// MockTokenService implementa TokenService para testing
type MockTokenService struct {
        tokens map[string]*entities.Token
}

func NewMockTokenService() *MockTokenService <span class="cov8" title="1">{
        return &amp;MockTokenService{
                tokens: make(map[string]*entities.Token),
        }
}</span>

func (m *MockTokenService) GenerateToken(user *entities.User) (*entities.Token, error) <span class="cov8" title="1">{
        token := &amp;entities.Token{
                Value:    "mock-jwt-token-" + user.ID,
                UserID:   user.ID,
                Username: user.Username,
        }
        m.tokens[user.ID] = token
        return token, nil
}</span>

func (m *MockTokenService) ValidateToken(tokenValue string) (*entities.TokenClaims, error) <span class="cov8" title="1">{
        for _, token := range m.tokens </span><span class="cov8" title="1">{
                if token.Value == tokenValue </span><span class="cov8" title="1">{
                        return &amp;entities.TokenClaims{
                                UserID:   token.UserID,
                                Username: token.Username,
                        }, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, errors.New("invalid token")</span>
}

func (m *MockTokenService) GetPublicKey() (string, error) <span class="cov0" title="0">{
        return "mock-public-key", nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package usecases

import (
        "auth-service/domain/repositories"
        "auth-service/domain/services"
        "auth-service/infrastructure/logger"
        "errors"
)

// LoginRequest representa la solicitud de login
// @Description Credenciales de autenticación del usuario
type LoginRequest struct {
        // @Description Nombre de usuario
        // @example admin
        Username string `json:"username" validate:"required,username"`
        // @Description Contraseña del usuario
        // @example Password123!
        Password string `json:"password" validate:"required,password"`
}

// LoginResponse representa la respuesta del login
// @Description Respuesta exitosa del login con token JWT
type LoginResponse struct {
        // @Description Token JWT generado para el usuario
        // @example eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
        Token string `json:"token"`
        // @Description Nombre de usuario autenticado
        // @example admin
        User string `json:"user"`
}

// LoginUseCase maneja la lógica de negocio para el login
type LoginUseCase struct {
        userRepo        repositories.UserRepository
        tokenService    services.TokenService
        passwordService services.PasswordService
}

// NewLoginUseCase crea una nueva instancia de LoginUseCase
func NewLoginUseCase(userRepo repositories.UserRepository, tokenService services.TokenService, passwordService services.PasswordService) *LoginUseCase <span class="cov8" title="1">{
        return &amp;LoginUseCase{
                userRepo:        userRepo,
                tokenService:    tokenService,
                passwordService: passwordService,
        }
}</span>

// Execute ejecuta el caso de uso de login
func (uc *LoginUseCase) Execute(request LoginRequest) (*LoginResponse, error) <span class="cov8" title="1">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "LoginUseCase.Execute",
                Data: map[string]interface{}{
                        "username": request.Username,
                },
        })

        logger.Info("Ejecutando caso de uso de login")

        // Buscar usuario por username
        logger.Info("Buscando usuario en repositorio")
        user, err := uc.userRepo.FindByUsername(request.Username)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Usuario no encontrado", err)
                return nil, errors.New("credenciales inválidas")
        }</span>

        <span class="cov8" title="1">logger.Info("Usuario encontrado", map[string]interface{}{
                "user_id": user.ID,
        })

        // Validar credenciales
        logger.Info("Validando credenciales del usuario")
        if !user.ValidateCredentials(request.Password, uc.passwordService) </span><span class="cov8" title="1">{
                logger.Error("Credenciales inválidas", errors.New("password incorrecto"))
                return nil, errors.New("credenciales inválidas")
        }</span>

        <span class="cov8" title="1">logger.Success("Credenciales validadas correctamente")

        // Generar token
        logger.Info("Generando token JWT")
        token, err := uc.tokenService.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error al generar token", err)
                return nil, errors.New("error generando token")
        }</span>

        <span class="cov8" title="1">logger.Success("Token generado exitosamente", map[string]interface{}{
                "user_id":  token.UserID,
                "username": token.Username,
        })

        return &amp;LoginResponse{
                Token: token.Value,
                User:  user.Username,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package usecases

import (
        "auth-service/domain/services"
        "auth-service/infrastructure/logger"
)

// ValidateTokenRequest representa la solicitud de validación de token
// @Description Token JWT a validar
type ValidateTokenRequest struct {
        // @Description Token JWT a validar
        // @example eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
        Token string `json:"token" validate:"required,jwt_token"`
}

// ValidateTokenResponse representa la respuesta de validación de token
// @Description Resultado de la validación del token JWT
type ValidateTokenResponse struct {
        // @Description Indica si el token es válido
        // @example true
        Valid bool `json:"valid"`
        // @Description Nombre de usuario del token (solo si es válido)
        // @example admin
        User string `json:"user,omitempty"`
        // @Description Mensaje de error (solo si el token es inválido)
        // @example token expired
        Error string `json:"error,omitempty"`
}

// ValidateTokenUseCase maneja la lógica de negocio para validar tokens
type ValidateTokenUseCase struct {
        tokenService services.TokenService
}

// NewValidateTokenUseCase crea una nueva instancia de ValidateTokenUseCase
func NewValidateTokenUseCase(tokenService services.TokenService) *ValidateTokenUseCase <span class="cov8" title="1">{
        return &amp;ValidateTokenUseCase{
                tokenService: tokenService,
        }
}</span>

// Execute ejecuta el caso de uso de validación de token
func (uc *ValidateTokenUseCase) Execute(request ValidateTokenRequest) *ValidateTokenResponse <span class="cov8" title="1">{
        // Establecer contexto para logging
        logger.SetContext(logger.Context{
                FunctionName: "ValidateTokenUseCase.Execute",
                Data: map[string]interface{}{
                        "token_length": len(request.Token),
                },
        })

        logger.Info("Ejecutando validación de token")

        // Validar token
        logger.Info("Validando token JWT")
        claims, err := uc.tokenService.ValidateToken(request.Token)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Token inválido", err)
                return &amp;ValidateTokenResponse{
                        Valid: false,
                        Error: err.Error(),
                }
        }</span>

        <span class="cov8" title="1">logger.Success("Token validado exitosamente", map[string]interface{}{
                "username": claims.Username,
                "user_id":  claims.UserID,
        })

        return &amp;ValidateTokenResponse{
                Valid: true,
                User:  claims.Username,
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
